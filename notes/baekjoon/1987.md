# 📝 백준 1987번 - 알파벳 (BFS / DFS) [🔗](https://www.acmicpc.net/problem/1987)

## **1. 문제 설명**

- `R x C` 크기의 격자가 주어지며, 각 칸에는 알파벳이 적혀 있다.
- `(0,0)`에서 시작하여 **같은 알파벳을 두 번 밟지 않고 최대한 많은 칸을 이동**해야 한다.
- 최대로 이동할 수 있는 칸 수를 구하는 문제.

### **제약 조건**

- `1 ≤ R, C ≤ 20`
- 다양한 경로에서 같은 칸을 방문할 수 있으나, 같은 경로에서는 같은 칸을 방문할 수 없다.

---

## **2. 초기 접근 방식 (오답)**

### **🚀 초기 접근 방식: `visited` 배열 사용**

- 일반적인 BFS 문제처럼 `visited[y][x]`를 사용하여 `(x, y)` 좌표 방문 여부를 체크하려 했다.
- 그러나 **이 문제에서는 "좌표 방문 여부"가 아니라, "이미 지나간 알파벳인지"가 중요**하다.

### **초기 접근 코드 (오답)**

```python
def count_dist():
    r, c = map(int, sys.stdin.readline().split())
    grid = [list(sys.stdin.readline().strip()) for _ in range(r)]
    visited = [[False]*c for _ in range (r)]
    visited_alpha = []  # 지나온 알파벳 저장 (리스트 사용)

    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    def bfs():
        max_dist = 1
        q = deque([(0, 0, 1)])
        visited_alpha.append(grid[0][0])  # 알파벳 저장
        visited[0][0] = True  # 좌표 방문 처리

        while q:
            cx, cy, dist = q.popleft()
            max_dist = max(max_dist, dist)

            for i in range(4):
                nx, ny = cx + dx[i], cy + dy[i]

                if 0 <= nx < c and 0 <= ny < r and not visited[ny][nx] and grid[ny][nx] not in visited_alpha:
                    visited_alpha.append(grid[ny][nx])  # 알파벳 추가
                    visited[ny][nx] = True  # 방문 처리
                    q.append((nx, ny, dist + 1))

        return max_dist

    return bfs()

print(count_dist())
```

### **❌ 문제점**
1. **`visited[y][x]`는 필요 없음**
   - **같은 좌표 `(x, y)`를 여러 경로로 방문할 수 있음.**
   - "이전에 방문한 알파벳이 있느냐?"가 중요함.

2. **`visited_alpha.append()` 방식이 비효율적**
   - **리스트(`list`)를 사용하면 `O(N)`의 탐색 비용이 듦.**
   - 대신 **해시셋(`set`)을 사용하면 `O(1)`로 탐색 가능**.

3. **경로마다 방문한 알파벳 목록이 달라야 함**
   - 현재 코드에서는 `visited_alpha`가 **모든 탐색에서 공유됨** → **잘못된 결과** 🚨
   - 각 경로마다 개별적으로 지나온 알파벳을 기록해야 함.

---

## **3. 올바른 접근법 (개선된 방식)**
### **🔍 핵심 아이디어**
✅ 좌표 방문 여부(`visited[y][x]`)가 아니라, **현재 경로에서 방문한 알파벳을 `set()`으로 관리**  
✅ **각 탐색 경로마다 개별적인 `set()`을 유지**해야 하므로 **`path | {grid[ny][nx]}`를 사용**  
✅ `set`은 중복을 허용하지 않고, 탐색(`in`)이 `O(1)`로 빠름  
### **📌 `set()`을 활용한 경로 관리 방법**
#### **🚀 예제**
예를 들어 `R = 2, C = 4`이고, 격자가 아래와 같다고 가정하자

```markdown
A B C D
B A D C
```
**1. 초기 상태**
- `(0, 0)`(A)에서 출발
- `path = {'A'}`

**2. 오른쪽(B)로 이동 가능**
- `(0, 1)`(B) 방문
- `path = {'A', 'B'}`

**3. 아래쪽(B)로 이동 가능?**
- `(1,1)`(A)인데 이미 방문한 'A'가 포함되므로 불가능 

**4. 오른쪽(C)로 이동 가능**
- `(0, 2)`(C) 방문
- `path = {'A', 'B', 'C'}`

-> 각 경로마다 독립적으로 방문한 알파벳을 추적할 수 있음

---

## **4. 최적화된 코드**
```python
import sys
from collections import deque

def count_dist():
    r, c = map(int, sys.stdin.readline().split())
    grid = [list(sys.stdin.readline().strip()) for _ in range(r)]

    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    def bfs():
        max_dist = 1
        q = deque([(0, 0, 1, {grid[0][0]})])  # (x, y, 이동 거리, 방문한 알파벳 set)

        while q:
            cx, cy, dist, path = q.popleft()
            max_dist = max(max_dist, dist)

            for i in range(4):
                nx, ny = cx + dx[i], cy + dy[i]

                if 0 <= nx < c and 0 <= ny < r and grid[ny][nx] not in path:
                    q.append((nx, ny, dist + 1, path | {grid[ny][nx]}))  # 새로운 set 생성

        return max_dist

    return bfs()

print(count_dist())
```

### **🚀 핵심 로직**
```python
q.append((nx, ny, dist + 1, path | {grid[ny][nx]}))
```
✅ `path | {grid[ny][nx]}`→ set을 새로 생성하여 알파벳 추가
✅ 기존 path를 변경하지 않고, 새로운 경로를 큐에 저장
✅ 이전 경로(path)는 그대로 유지되므로, 다른 경로에서도 독립적으로 탐색 가능