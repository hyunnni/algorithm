# ğŸ“ ë°±ì¤€ 1987ë²ˆ - ì•ŒíŒŒë²³ (BFS / DFS) [ğŸ”—](https://www.acmicpc.net/problem/1987)

## **1. ë¬¸ì œ ì„¤ëª…**

- `R x C` í¬ê¸°ì˜ ê²©ìê°€ ì£¼ì–´ì§€ë©°, ê° ì¹¸ì—ëŠ” ì•ŒíŒŒë²³ì´ ì í˜€ ìˆë‹¤.
- `(0,0)`ì—ì„œ ì‹œì‘í•˜ì—¬ **ê°™ì€ ì•ŒíŒŒë²³ì„ ë‘ ë²ˆ ë°Ÿì§€ ì•Šê³  ìµœëŒ€í•œ ë§ì€ ì¹¸ì„ ì´ë™**í•´ì•¼ í•œë‹¤.
- ìµœëŒ€ë¡œ ì´ë™í•  ìˆ˜ ìˆëŠ” ì¹¸ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ.

### **ì œì•½ ì¡°ê±´**

- `1 â‰¤ R, C â‰¤ 20`
- ë‹¤ì–‘í•œ ê²½ë¡œì—ì„œ ê°™ì€ ì¹¸ì„ ë°©ë¬¸í•  ìˆ˜ ìˆìœ¼ë‚˜, ê°™ì€ ê²½ë¡œì—ì„œëŠ” ê°™ì€ ì¹¸ì„ ë°©ë¬¸í•  ìˆ˜ ì—†ë‹¤.

---

## **2. ì´ˆê¸° ì ‘ê·¼ ë°©ì‹ (ì˜¤ë‹µ)**

### **ğŸš€ ì´ˆê¸° ì ‘ê·¼ ë°©ì‹: `visited` ë°°ì—´ ì‚¬ìš©**

- ì¼ë°˜ì ì¸ BFS ë¬¸ì œì²˜ëŸ¼ `visited[y][x]`ë¥¼ ì‚¬ìš©í•˜ì—¬ `(x, y)` ì¢Œí‘œ ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì²´í¬í•˜ë ¤ í–ˆë‹¤.
- ê·¸ëŸ¬ë‚˜ **ì´ ë¬¸ì œì—ì„œëŠ” "ì¢Œí‘œ ë°©ë¬¸ ì—¬ë¶€"ê°€ ì•„ë‹ˆë¼, "ì´ë¯¸ ì§€ë‚˜ê°„ ì•ŒíŒŒë²³ì¸ì§€"ê°€ ì¤‘ìš”**í•˜ë‹¤.

### **ì´ˆê¸° ì ‘ê·¼ ì½”ë“œ (ì˜¤ë‹µ)**

```python
def count_dist():
    r, c = map(int, sys.stdin.readline().split())
    grid = [list(sys.stdin.readline().strip()) for _ in range(r)]
    visited = [[False]*c for _ in range (r)]
    visited_alpha = []  # ì§€ë‚˜ì˜¨ ì•ŒíŒŒë²³ ì €ì¥ (ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©)

    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    def bfs():
        max_dist = 1
        q = deque([(0, 0, 1)])
        visited_alpha.append(grid[0][0])  # ì•ŒíŒŒë²³ ì €ì¥
        visited[0][0] = True  # ì¢Œí‘œ ë°©ë¬¸ ì²˜ë¦¬

        while q:
            cx, cy, dist = q.popleft()
            max_dist = max(max_dist, dist)

            for i in range(4):
                nx, ny = cx + dx[i], cy + dy[i]

                if 0 <= nx < c and 0 <= ny < r and not visited[ny][nx] and grid[ny][nx] not in visited_alpha:
                    visited_alpha.append(grid[ny][nx])  # ì•ŒíŒŒë²³ ì¶”ê°€
                    visited[ny][nx] = True  # ë°©ë¬¸ ì²˜ë¦¬
                    q.append((nx, ny, dist + 1))

        return max_dist

    return bfs()

print(count_dist())
```

### **âŒ ë¬¸ì œì **
1. **`visited[y][x]`ëŠ” í•„ìš” ì—†ìŒ**
   - **ê°™ì€ ì¢Œí‘œ `(x, y)`ë¥¼ ì—¬ëŸ¬ ê²½ë¡œë¡œ ë°©ë¬¸í•  ìˆ˜ ìˆìŒ.**
   - "ì´ì „ì— ë°©ë¬¸í•œ ì•ŒíŒŒë²³ì´ ìˆëŠëƒ?"ê°€ ì¤‘ìš”í•¨.

2. **`visited_alpha.append()` ë°©ì‹ì´ ë¹„íš¨ìœ¨ì **
   - **ë¦¬ìŠ¤íŠ¸(`list`)ë¥¼ ì‚¬ìš©í•˜ë©´ `O(N)`ì˜ íƒìƒ‰ ë¹„ìš©ì´ ë“¦.**
   - ëŒ€ì‹  **í•´ì‹œì…‹(`set`)ì„ ì‚¬ìš©í•˜ë©´ `O(1)`ë¡œ íƒìƒ‰ ê°€ëŠ¥**.

3. **ê²½ë¡œë§ˆë‹¤ ë°©ë¬¸í•œ ì•ŒíŒŒë²³ ëª©ë¡ì´ ë‹¬ë¼ì•¼ í•¨**
   - í˜„ì¬ ì½”ë“œì—ì„œëŠ” `visited_alpha`ê°€ **ëª¨ë“  íƒìƒ‰ì—ì„œ ê³µìœ ë¨** â†’ **ì˜ëª»ëœ ê²°ê³¼** ğŸš¨
   - ê° ê²½ë¡œë§ˆë‹¤ ê°œë³„ì ìœ¼ë¡œ ì§€ë‚˜ì˜¨ ì•ŒíŒŒë²³ì„ ê¸°ë¡í•´ì•¼ í•¨.

---

## **3. ì˜¬ë°”ë¥¸ ì ‘ê·¼ë²• (ê°œì„ ëœ ë°©ì‹)**
### **ğŸ” í•µì‹¬ ì•„ì´ë””ì–´**
âœ… ì¢Œí‘œ ë°©ë¬¸ ì—¬ë¶€(`visited[y][x]`)ê°€ ì•„ë‹ˆë¼, **í˜„ì¬ ê²½ë¡œì—ì„œ ë°©ë¬¸í•œ ì•ŒíŒŒë²³ì„ `set()`ìœ¼ë¡œ ê´€ë¦¬**  
âœ… **ê° íƒìƒ‰ ê²½ë¡œë§ˆë‹¤ ê°œë³„ì ì¸ `set()`ì„ ìœ ì§€**í•´ì•¼ í•˜ë¯€ë¡œ **`path | {grid[ny][nx]}`ë¥¼ ì‚¬ìš©**  
âœ… `set`ì€ ì¤‘ë³µì„ í—ˆìš©í•˜ì§€ ì•Šê³ , íƒìƒ‰(`in`)ì´ `O(1)`ë¡œ ë¹ ë¦„  
### **ğŸ“Œ `set()`ì„ í™œìš©í•œ ê²½ë¡œ ê´€ë¦¬ ë°©ë²•**
#### **ğŸš€ ì˜ˆì œ**
ì˜ˆë¥¼ ë“¤ì–´ `R = 2, C = 4`ì´ê³ , ê²©ìê°€ ì•„ë˜ì™€ ê°™ë‹¤ê³  ê°€ì •í•˜ì

```markdown
A B C D
B A D C
```
**1. ì´ˆê¸° ìƒíƒœ**
- `(0, 0)`(A)ì—ì„œ ì¶œë°œ
- `path = {'A'}`

**2. ì˜¤ë¥¸ìª½(B)ë¡œ ì´ë™ ê°€ëŠ¥**
- `(0, 1)`(B) ë°©ë¬¸
- `path = {'A', 'B'}`

**3. ì•„ë˜ìª½(B)ë¡œ ì´ë™ ê°€ëŠ¥?**
- `(1,1)`(A)ì¸ë° ì´ë¯¸ ë°©ë¬¸í•œ 'A'ê°€ í¬í•¨ë˜ë¯€ë¡œ ë¶ˆê°€ëŠ¥ 

**4. ì˜¤ë¥¸ìª½(C)ë¡œ ì´ë™ ê°€ëŠ¥**
- `(0, 2)`(C) ë°©ë¬¸
- `path = {'A', 'B', 'C'}`

-> ê° ê²½ë¡œë§ˆë‹¤ ë…ë¦½ì ìœ¼ë¡œ ë°©ë¬¸í•œ ì•ŒíŒŒë²³ì„ ì¶”ì í•  ìˆ˜ ìˆìŒ

---

## **4. ìµœì í™”ëœ ì½”ë“œ**
```python
import sys
from collections import deque

def count_dist():
    r, c = map(int, sys.stdin.readline().split())
    grid = [list(sys.stdin.readline().strip()) for _ in range(r)]

    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    def bfs():
        max_dist = 1
        q = deque([(0, 0, 1, {grid[0][0]})])  # (x, y, ì´ë™ ê±°ë¦¬, ë°©ë¬¸í•œ ì•ŒíŒŒë²³ set)

        while q:
            cx, cy, dist, path = q.popleft()
            max_dist = max(max_dist, dist)

            for i in range(4):
                nx, ny = cx + dx[i], cy + dy[i]

                if 0 <= nx < c and 0 <= ny < r and grid[ny][nx] not in path:
                    q.append((nx, ny, dist + 1, path | {grid[ny][nx]}))  # ìƒˆë¡œìš´ set ìƒì„±

        return max_dist

    return bfs()

print(count_dist())
```

### **ğŸš€ í•µì‹¬ ë¡œì§**
```python
q.append((nx, ny, dist + 1, path | {grid[ny][nx]}))
```
âœ… `path | {grid[ny][nx]}`â†’ setì„ ìƒˆë¡œ ìƒì„±í•˜ì—¬ ì•ŒíŒŒë²³ ì¶”ê°€
âœ… ê¸°ì¡´ pathë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³ , ìƒˆë¡œìš´ ê²½ë¡œë¥¼ íì— ì €ì¥
âœ… ì´ì „ ê²½ë¡œ(path)ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€ë˜ë¯€ë¡œ, ë‹¤ë¥¸ ê²½ë¡œì—ì„œë„ ë…ë¦½ì ìœ¼ë¡œ íƒìƒ‰ ê°€ëŠ¥